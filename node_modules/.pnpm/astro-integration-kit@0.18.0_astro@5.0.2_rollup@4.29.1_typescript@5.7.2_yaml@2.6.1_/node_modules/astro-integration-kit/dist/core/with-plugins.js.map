{"version":3,"sources":["../../src/core/with-plugins.ts"],"sourcesContent":["import type { AstroIntegration, HookParameters } from \"astro\";\nimport type { NonEmptyArray, Prettify } from \"../internal/types.js\";\nimport type { AddedParam, AnyPlugin, ExtendedHooks, Hooks } from \"./types.js\";\n\ntype WithPluginsParams<TPlugins extends NonEmptyArray<AnyPlugin>> = {\n\tname: string;\n\tplugins: TPlugins;\n\thooks: ExtendedHooks<TPlugins>;\n};\n\nexport type WithPluginsReturn<Extensions> = Extensions &\n\tOmit<AstroIntegration, \"name\">;\n\n/**\n * Allows to extend hooks with custom parameters. Only used for advanced use-cases.\n *\n * @param {object} params\n * @param {string} params.name The integration name\n * @param {Array<AnyPlugin>} params.plugins\n * @param {import(\"astro\".AstroIntegration[\"hooks\"])} params.hooks\n */\nexport const withPlugins = <\n\tTPlugins extends NonEmptyArray<AnyPlugin>,\n\tExtensions extends Record<any, unknown>,\n>(\n\toptions: WithPluginsParams<TPlugins> & Extensions,\n): WithPluginsReturn<\n\tPrettify<Omit<Extensions, keyof WithPluginsParams<any>>>\n> => {\n\tconst {\n\t\tname,\n\t\tplugins,\n\t\thooks: providedHooks,\n\t\t...remainingIntegrationObject\n\t} = options;\n\n\t// Overrides plugins with same name\n\t// Overrides plugins with same name, keeping only the last occurrence\n\tconst resolvedPlugins = plugins\n\t\t.filter(\n\t\t\t(plugin, index, self) =>\n\t\t\t\tself.findLastIndex((other) => other.name === plugin.name) === index,\n\t\t)\n\t\t// Setup plugins with the integration parameters\n\t\t.map(\n\t\t\t(\n\t\t\t\tplugin,\n\t\t\t): Partial<\n\t\t\t\tRecord<keyof Hooks, (params: any) => Record<string, unknown>>\n\t\t\t> => plugin.setup({ name }),\n\t\t);\n\n\tconst definedHooks = ([\n\t\t...Object.keys(providedHooks),\n\t\t...resolvedPlugins.flatMap(Object.keys),\n\t] as Array<keyof Hooks>)\n\t\t// Deduplicate the hook names\n\t\t.filter((hookName, index, list) => list.indexOf(hookName) === index);\n\n\tconst hooks: AstroIntegration[\"hooks\"] = Object.fromEntries(\n\t\tdefinedHooks.map((hookName) => [\n\t\t\thookName,\n\t\t\t// We know all hook parameters are objects, but the generic correlation makes TS ignore that fact.\n\t\t\t// The intersection with `object` is a workaround so TS doesn't complain about the spread below.\n\t\t\t(params: object & HookParameters<typeof hookName>) => {\n\t\t\t\tconst plugins = resolvedPlugins.filter(\n\t\t\t\t\t(p): p is Required<Pick<typeof p, typeof hookName>> =>\n\t\t\t\t\t\thookName in p && !!p[hookName],\n\t\t\t\t);\n\n\t\t\t\tconst additionalParams = {} as AddedParam<TPlugins, typeof hookName>;\n\n\t\t\t\tfor (const plugin of plugins) {\n\t\t\t\t\tObject.assign(additionalParams, plugin[hookName](params));\n\t\t\t\t}\n\n\t\t\t\treturn providedHooks[hookName]?.({\n\t\t\t\t\t...additionalParams,\n\t\t\t\t\t...params,\n\t\t\t\t} as any);\n\t\t\t},\n\t\t]),\n\t);\n\n\treturn {\n\t\thooks,\n\t\t...remainingIntegrationObject,\n\t};\n};\n"],"mappings":"AAqBO,IAAMA,EAIZC,GAGI,CACJ,GAAM,CACL,KAAAC,EACA,QAAAC,EACA,MAAOC,EACP,GAAGC,CACJ,EAAIJ,EAIEK,EAAkBH,EACtB,OACA,CAACI,EAAQC,EAAOC,IACfA,EAAK,cAAeC,GAAUA,EAAM,OAASH,EAAO,IAAI,IAAMC,CAChE,EAEC,IAECD,GAGIA,EAAO,MAAM,CAAE,KAAAL,CAAK,CAAC,CAC3B,EAEKS,EAAgB,CACrB,GAAG,OAAO,KAAKP,CAAa,EAC5B,GAAGE,EAAgB,QAAQ,OAAO,IAAI,CACvC,EAEE,OAAO,CAACM,EAAUJ,EAAOK,IAASA,EAAK,QAAQD,CAAQ,IAAMJ,CAAK,EA2BpE,MAAO,CACN,MA1BwC,OAAO,YAC/CG,EAAa,IAAKC,GAAa,CAC9BA,EAGCE,GAAqD,CACrD,IAAMX,EAAUG,EAAgB,OAC9BS,GACAH,KAAYG,GAAK,CAAC,CAACA,EAAEH,CAAQ,CAC/B,EAEMI,EAAmB,CAAC,EAE1B,QAAWT,KAAUJ,EACpB,OAAO,OAAOa,EAAkBT,EAAOK,CAAQ,EAAEE,CAAM,CAAC,EAGzD,OAAOV,EAAcQ,CAAQ,IAAI,CAChC,GAAGI,EACH,GAAGF,CACJ,CAAQ,CACT,CACD,CAAC,CACF,EAIC,GAAGT,CACJ,CACD","names":["withPlugins","options","name","plugins","providedHooks","remainingIntegrationObject","resolvedPlugins","plugin","index","self","other","definedHooks","hookName","list","params","p","additionalParams"]}