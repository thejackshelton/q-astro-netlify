import { AstroIntegration } from 'astro';
import { z } from 'astro/zod';
import { ExtendedPrettify } from '../internal/types.js';
import { Hooks } from './types.js';

type AstroIntegrationSetupFn<Options extends z.ZodTypeAny, TApi> = (params: {
    name: string;
    options: z.output<Options>;
}) => Omit<AstroIntegration, "name" | "hooks"> & TApi & {
    hooks: Partial<Hooks>;
};
/**
 * A powerful wrapper around the standard Astro Integrations API. It allows integration authors to handle user options and global logic easily.
 *
 * @param {object} params
 * @param {string} params.name - The name of your integration
 * @param {import("astro/zod").AnyZodObject} params.optionsSchema - An optional zod schema to handle your integration options
 * @param {function} params.setup - This will be called from your `astro:config:setup` call with the user options
 *
 * @see https://astro-integration-kit.netlify.app/core/define-integration/
 *
 * @example
 * ```ts
 * export default defineIntegration({
 * 		name: "my-integration",
 * 		setup({ options }) {
 * 			console.log(options.foo); // "bar"
 * 		}
 * })
 * ```
 */
declare const defineIntegration: <TApiBase, TApi extends ExtendedPrettify<Omit<TApiBase, keyof AstroIntegration>>, TOptionsSchema extends z.ZodTypeAny = z.ZodNever>({ name, optionsSchema, setup, }: {
    name: string;
    optionsSchema?: TOptionsSchema;
    setup: AstroIntegrationSetupFn<TOptionsSchema, TApiBase>;
}) => ((...args: [z.input<TOptionsSchema>] extends [
    never
] ? [
] : undefined extends z.input<TOptionsSchema> ? [options?: z.input<TOptionsSchema>] : [options: z.input<TOptionsSchema>]) => AstroIntegration & TApi);

export { defineIntegration };
