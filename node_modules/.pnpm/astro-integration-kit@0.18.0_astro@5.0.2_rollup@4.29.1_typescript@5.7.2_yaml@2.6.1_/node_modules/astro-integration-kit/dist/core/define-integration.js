import{AstroError as y}from"astro/errors";import{z as g}from"astro/zod";var u=(e,n)=>{let o=c(e.path);if(e.code==="invalid_union"){let r=new Map;for(let t of e.unionErrors.flatMap(i=>i.errors))if(t.code==="invalid_type"||t.code==="invalid_literal"){let i=c(t.path);r.has(i)?r.get(i).expected.push(t.expected):r.set(i,{code:t.code,received:t.received,expected:[t.expected]})}return{message:[s(o,r.size?"Did not match union:":"Did not match union.")].concat([...r.entries()].filter(([,t])=>t.expected.length===e.unionErrors.length).map(([t,i])=>t===o?`> ${a(i)}`:`> ${s(t,a(i))}`)).join(`
`)}}return e.code==="invalid_literal"||e.code==="invalid_type"?{message:s(o,a({code:e.code,received:e.received,expected:[e.expected]}))}:e.message?{message:s(o,e.message)}:{message:s(o,n.defaultError)}},a=e=>{if(e.received==="undefined")return"Required";let n=new Set(e.expected);switch(e.code){case"invalid_type":return`Expected type \`${d(n)}\`, received ${JSON.stringify(e.received)}`;case"invalid_literal":return`Expected \`${d(n)}\`, received ${JSON.stringify(e.received)}`}},s=(e,n)=>e.length?`**${e}**: ${n}`:n,d=e=>[...e].map((n,o)=>o===0?JSON.stringify(n):` | ${JSON.stringify(n)}`).join(""),c=e=>e.join(".");var T=({name:e,optionsSchema:n,setup:o})=>(...r)=>{let p=(n??g.never().optional()).safeParse(r[0],{errorMap:u});if(!p.success)throw new y(`Invalid options passed to "${e}" integration
`,p.error.issues.map(l=>l.message).join(`
`));let t=p.data,{hooks:i,...m}=o({name:e,options:t});return{...m,hooks:i,name:e}};export{T as defineIntegration};
//# sourceMappingURL=define-integration.js.map