import{fileURLToPath as S}from"node:url";import{dirname as E,resolve as j}from"pathe";var b=e=>{let t=e;return t.startsWith("file://")&&(t=E(S(t))),{resolve:(...n)=>j(t,...n)}};import{AstroError as U}from"astro/errors";import{z as N}from"astro/zod";var H=(e,t)=>{let n=v(e.path);if(e.code==="invalid_union"){let o=new Map;for(let i of e.unionErrors.flatMap(s=>s.errors))if(i.code==="invalid_type"||i.code==="invalid_literal"){let s=v(i.path);o.has(s)?o.get(s).expected.push(i.expected):o.set(s,{code:i.code,received:i.received,expected:[i.expected]})}return{message:[u(n,o.size?"Did not match union:":"Did not match union.")].concat([...o.entries()].filter(([,i])=>i.expected.length===e.unionErrors.length).map(([i,s])=>i===n?`> ${h(s)}`:`> ${u(i,h(s))}`)).join(`
`)}}return e.code==="invalid_literal"||e.code==="invalid_type"?{message:u(n,h({code:e.code,received:e.received,expected:[e.expected]}))}:e.message?{message:u(n,e.message)}:{message:u(n,t.defaultError)}},h=e=>{if(e.received==="undefined")return"Required";let t=new Set(e.expected);switch(e.code){case"invalid_type":return`Expected type \`${k(t)}\`, received ${JSON.stringify(e.received)}`;case"invalid_literal":return`Expected \`${k(t)}\`, received ${JSON.stringify(e.received)}`}},u=(e,t)=>e.length?`**${e}**: ${t}`:t,k=e=>[...e].map((t,n)=>n===0?JSON.stringify(t):` | ${JSON.stringify(t)}`).join(""),v=e=>e.join(".");var C=({name:e,optionsSchema:t,setup:n})=>(...o)=>{let r=(t??N.never().optional()).safeParse(o[0],{errorMap:H});if(!r.success)throw new U(`Invalid options passed to "${e}" integration
`,r.error.issues.map(l=>l.message).join(`
`));let i=r.data,{hooks:s,...a}=n({name:e,options:i});return{...a,hooks:s,name:e}};var P=e=>e;var D=e=>P({...e,setup:(...t)=>{let n=e.setup(...t);return new Proxy(Object.freeze({}),{has:(o,r)=>typeof r=="string",get:(o,r)=>n(r)})}});var p=e=>t=>t;var V=e=>{let{name:t,plugins:n,hooks:o,...r}=e,i=n.filter((l,c,d)=>d.findLastIndex(f=>f.name===l.name)===c).map(l=>l.setup({name:t})),s=[...Object.keys(o),...i.flatMap(Object.keys)].filter((l,c,d)=>d.indexOf(l)===c);return{hooks:Object.fromEntries(s.map(l=>[l,c=>{let d=i.filter(g=>l in g&&!!g[l]),f={};for(let g of d)Object.assign(f,g[l](c));return o[l]?.({...f,...c})}])),...r}};import{mkdirSync as L,readFileSync as z,writeFileSync as I}from"node:fs";import{dirname as _,relative as M}from"node:path";import{fileURLToPath as y}from"node:url";import{parse as W,prettyPrint as F}from"recast";import Q from"recast/parsers/typescript.js";var B=({srcDir:e,logger:t,specifier:n})=>{let o=y(new URL("env.d.ts",e));n instanceof URL&&(n=y(n),n=M(y(e),n),n=n.replaceAll("\\","/"));let r=z(o,"utf8");if(r.includes(`/// <reference types='${n}' />`)||r.includes(`/// <reference types="${n}" />`))return;let i=r.includes("/// <reference types='astro/client' />")?{singleQuotes:!0,hasClient:!0}:r.includes('/// <reference types="astro/client" />')?{singleQuotes:!1,hasClient:!0}:r.includes('/// <reference path="../.astro/types.d.ts" />')?{singleQuotes:!1,hasClient:!1}:{singleQuotes:!0,hasClient:!1},s=`/// <reference ${i.hasClient?"types":"path"}=${i.singleQuotes?"'":'"'}${i.hasClient?"astro/client":"../.astro/types.d.ts"}${i.singleQuotes?"'":'"'} />`,a=r.replace(s,`${s}
/// <reference types=${i.singleQuotes?"'":'"'}${n}${i.singleQuotes?"'":'"'} />`);a!==r&&(I(o,a),t.info("Updated env.d.ts types"))},Z=p("astro:config:setup")(({config:{root:e,srcDir:t},logger:n},{name:o,content:r})=>{let i=new URL(`.astro/${o}.d.ts`,e),s=y(i);B({srcDir:t,logger:n,specifier:i}),L(_(s),{recursive:!0}),I(s,F(W(r,{parser:Q}),{tabWidth:4}).code,"utf-8")});import{AstroError as w}from"astro/errors";function x(e){let t=[];if(e){for(let n of e)if(n){if(Array.isArray(n)){t.push(...x(n));continue}n instanceof Promise||t.push(n.name)}}return t}var m=p("astro:config:setup")(({config:e},{plugin:t})=>{if(!t||t instanceof Promise)return!1;let n=new Set(x(e?.vite?.plugins)),o=new Set;if(typeof t=="string"&&o.add(t),typeof t=="object")if(Array.isArray(t)){let r=new Set(x(t));for(let i of r)o.add(i)}else o.add(t.name);return[...o].some(r=>n.has(r))});var T=p("astro:config:setup")((e,{plugin:t,warnDuplicated:n=!0})=>{let{updateConfig:o,logger:r}=e;n&&m(e,{plugin:t})&&r.warn(`The Vite plugin "${t.name}" is already present in your Vite configuration, this plugin may not behave correctly.`),o({vite:{plugins:[t]}})});var J=e=>{let t=1;return`${e.replace(/-(\d+)$/,(n,o)=>(t=parseInt(o)+1,""))}-${t}`},O=e=>`\0${e}`,q=(e,t,n)=>{let o=Array.isArray(t)?t:Object.entries(t).map(([s,a])=>({id:s,content:a,context:void 0})),r={};for(let{id:s,context:a}of o)r[s]??=[],r[s]?.push(...a===void 0?["server","client"]:[a]);for(let[s,a]of Object.entries(r))if(a.length!==[...new Set(a)].length)throw new w(`Virtual import with id "${s}" has been registered several times with conflicting contexts.`);let i=Object.fromEntries(o.map(({id:s})=>{if(!n&&s.startsWith("astro:"))throw new w(`Virtual import name prefix can't be "astro:" (for "${s}") because it's reserved for Astro core.`);return[O(s),s]}));return{name:e,resolveId(s){if(o.find(a=>a.id===s))return O(s)},load(s,a){let l=i[s];if(l){let c=a?.ssr?"server":"client",d=o.find(f=>f.id===l&&(f.context===void 0||f.context===c));if(d)return d.content}}}},Y=p("astro:config:setup")((e,{name:t,imports:n,__enableCorePowerDoNotUseOrYouWillBeFired:o=!1})=>{let r=`vite-plugin-${t}`;for(;m(e,{plugin:r});)r=J(r);T(e,{warnDuplicated:!1,plugin:q(r,n,o)})});import{AstroError as $}from"astro/errors";var A=p("astro:config:setup")(({config:e},{name:t,position:n,relativeTo:o})=>{let r=e.integrations.findIndex(s=>s.name===t);if(r===-1)return!1;if(n===void 0)return!0;if(o===void 0)throw new $("Cannot perform a relative integration check without a relative reference.","Pass `relativeTo` on your call to `hasIntegration` or remove the `position` option.");let i=e.integrations.findIndex(s=>s.name===o);if(i===-1)throw new $("Cannot check relative position against an absent integration.");return n==="before"?r<i:r>i});var G=p("astro:config:setup")(({command:e,injectRoute:t},n)=>{e==="dev"&&t(n)});import{readdirSync as K,statSync as X}from"node:fs";import{join as ee,relative as te,resolve as ne}from"pathe";var R=(e,t=e)=>{let n=K(e),o=[];for(let r of n){let i=ee(e,r);if(X(i).isDirectory()){let a=R(i,t);o=o.concat(a)}else{let a=te(t,i);o.push(a)}}return o},oe=p("astro:config:setup")(({addWatchFile:e,command:t,updateConfig:n},o)=>{if(t!=="dev")return;let r=R(o).map(i=>ne(o,i));for(let i of r)e(i);n({vite:{plugins:[{name:`rollup-aik-watch-directory-${o}`,buildStart(){for(let i of r)this.addWatchFile(i)}}]}})});import"astro";var re=p("astro:config:setup")((e,{integration:t,ensureUnique:n})=>{let{logger:o,updateConfig:r}=e;if(n&&A(e,{name:t.name})){o.warn(`Integration "${t.name}" has already been added by the user or another integration. Skipping.`);return}r({integrations:[t]})});export{Z as addDts,re as addIntegration,Y as addVirtualImports,T as addVitePlugin,b as createResolver,D as defineAllHooksPlugin,C as defineIntegration,P as definePlugin,p as defineUtility,A as hasIntegration,m as hasVitePlugin,G as injectDevRoute,oe as watchDirectory,V as withPlugins};
//# sourceMappingURL=index.js.map